# Почему haskell

Сперва хочется отметить, что язык haskell был выбран как необходимое зло для
данного проекта. Экзотичность и суровая кривая обучения данного языка является
серьёзной проблемой. Были сделаны попытки найти альтернативные варианты, но, как
не странно, именно haskell оказался наиболее практичным и удобным вариантом. С
другими языками либо проваливалась производительность, либо усложнялось
тестирование, либо возлагались серьёзные ограничения на стиль программирования.
Не просто так Haskell популярен в среде компиляторо-строения.

Следующие особенности проекта и языка стали определяющими:

1. Метод синтеза. В его основе лежит имитационная модель вычислителя, используя
   которую система синтеза перебирает возможные варианты организации
   вычислительного процесса, формируемые последовательностями принимаемых
   решений. В случае если выясняется, что выбранный вариант неудовлетворителен -
   необходимо осуществить откат части принятых решений. Haskell - функциональный
   язык программирования работающий с неизменяемыми данными (вместо того что бы
   обновить значение в словаре, мы создаём новый словарь), и вся его
   инфраструктура рассчитана на это. Это позволяет нам:
    1. Получить функцию «отката изменений» бесплатно, безопасно и при этом не
       нагружая программиста или инструментальную машину.
    2. Обеспечить параллельный синтез на разных ядрах или на кластере.
2. Разрабатываемый САПР является сложным программным продуктом включающим в себя
   большое количество тесно связанных компонент. При этом состав компонент и их
   функциональность будут часто меняться. Это ставит проблему обеспечения
   согласованности компонент системы, решением которой обычно является строгая
   статическая типизация. Про Haskell часто говорят, что если программа
   «собралась», то она будет работать. Конечно это не так, но если сравнить с
   привычными языками, то это скорее правда.
3. При решении комплексных вычислительных задач не требующих ввода/вывода, с
   большим количеством условий и инвариантов, серьёзную проблему представляет
   управление порядком вычислений. Когда какую метрику рассчитать. Что посчитать
   сейчас, а что по мере анализа вариантов. Будучи ленивым языком
   программирования, язык Haskell разбирается с этой проблемой сам, без участия
   программиста, что значительно упрощает процесс разработки (и несколько
   затрудняет процесс отладки).
4. Интересные и эффективные приемы разработки, поддержка embedded domain
   Specific language, неплохие библиотеки (например:
   https://hackage.haskell.org/package/QuickCheck ).
5. https://www.haskell.org
