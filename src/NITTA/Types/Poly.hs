{-# LANGUAGE FlexibleContexts       #-}
{-# LANGUAGE FlexibleInstances      #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE MultiParamTypeClasses  #-}
{-# LANGUAGE PolyKinds              #-}
{-# LANGUAGE RecordWildCards        #-}
{-# LANGUAGE ScopedTypeVariables    #-}
{-# LANGUAGE TypeFamilies           #-}
{-# LANGUAGE UndecidableInstances   #-}
{-# OPTIONS -Wall -fno-warn-missing-signatures #-}

{-
По большому счёту выносить это объявление типа в отдельный модуль обусловлено расширением PolyKinds,
из-за которого компилятор перестают правильно воспринимать переменные типов без аннотаций и надо
существенно переписывать код.
-}
module NITTA.Types.Poly where

import           Data.Proxy

-- | Общий класс для описания варантов и решений.
--
-- Инстансы данного класса должны оканчиваться иметь суфикс DT. Например: BindingDT. Конктрукторы
-- опций должны иметь суфикс O, а решений - D.
class DecisionType (t :: *) where
  data Option_ t :: *
  data Decision_ t :: *

-- | Общий интерфейс для работы с принятия решений. Единственная проблема - он требует явного
-- прописывания Proxy типа, что в общем-то сильно колечит саму идею общего интерфейса. Может быть,
-- когда-нибудь удастся это дело поправить.
--
-- С чем связана проблема:
--
-- - Описание варианта (Option_) и решения (Decision_) должны специализироваться по типам.
--   Есть три способа это обеспечить: 1) Определить необходимый kind для Option_ и Decision_, а их
--   значения явно указывать в классе Decision (не подходит, так как не понятно какой должен быть
--   kind). 2) Объявить все необходимые переменные непосредственно в типе DesicionType, значения
--   которых будут связываться при объявлении инстанса класс Decision.
-- - Если выбран вариант 2, то необъодимо согласовать между собой типы источника вариантов (s) и
--   типов ваниарта (t). Делать это вручную - очень много кода. По этому определяется функциональная
--   зависимость s -> t, которая не приводит к колизии, если один объект реализуется несколько
--   вариантов типов решений.
--
-- На текущий момент данный класс можно разбить на несколько классов, количество которых будет
-- равно количеству инстансов DecisionType. Возможный способ использования - инкапсулировать тип
-- решения в рамках процедуры принятия решения (но осмысленность данного действия не ясна).
class Decision dt (t :: *) (s :: *) | dt s -> t where
  options_ :: Proxy dt -> s -> [Option_ t]
  decision_ :: Proxy dt -> s -> Decision_ t -> s
